const n=20;
const array=[];

init();                       // By having this function declared early, it prevents you from having to press the "init" button everytime you want to start it again, and now, all you have to do is refresh the page.

let audioCtx=null;

function playNote(freq) {
    if(audioCtx==null) {
        audioCtx=new(
            AudioContext ||
            webkitAudioContext ||
            window.webkitAudioContext
        )();
    }
    const dur=0.1;
    const osc=audioCtx.createOscillator();
    osc.frequency.value=freq;
    osc.start();
    osc.stop(audioCtx.currentTime+dur);
    const node = audioCtx.createGain();
    node.gain.value=0.1;
    node.gain.linearRampToValueAtTime(
        0, audioCtx.currentTime+dur
    );
    osc.connect(node);
    node.connect(audioCtx.destination);
}


function init() {
   for(let i=0;i<n;i++){
      array[i]=Math.random(); // For each iteration, a number between 0 and 1 will be generated by Math.random(). This method only generates numbers betweens 0 and 1 unless specified otherwise.
   }
   showBars();
}

function play(){
   const copy=[...array];
   const moves=bubbleSort(copy);
    animate(moves);
}

function animate(moves) {
    if(moves.length==0) {
        showBars();
        return;
    }
    const move =moves.shift();
    const [i,j]=move.indices;

    if(move.type== "swap") {
        [array[i],array[j]]=[array[j],array[i]];
    }
    playNote(200+array[i]*500);
    playNote(200+array[j]*500);
    showBars(move);
    setTimeout(function(){
        animate(moves);
    }, 50); 
}


function bubbleSort(array) {
    const moves=[];
    do{
        var swapped=false;
        for(let i=1;i<array.length;i++){                     // keeps the function going until length of array is reached.
            // moves.push({indices:[i-1,i],type:"comp"});       // in this step, "moves" is adding 2 values(indices), and comparing the 2, to see which one is greater.
            if(array[i-1]>array[i]){                         // if the current array value is greater than the next value, swap them (creating an ascending order of bars)
                swapped=true;
                moves.push({indices:[i-1,i],type:"swap"});   // in this step, "moves" is swapping the 2 values(indices).
                [array[i-1],array[i]]=[array[i],array[i-1]];  //?? This is apparently a destructuring assignment to swap the elements. It's basically saying that if there is an i, i-1, it is now in the order of i-1, i. (from descending to ascending order)
            }
        }
    }while(swapped);
    return moves;                                          // I believe this is simply saying that while swapped = true, all of the above should occur within the for loop.
}




function showBars(move) {
    container.innerHTML="";                          // this simply clears ("") the entire container each time you prepare to generate new bars again. In this case, "innerHTML" refers to the HTML content within the "container".
    for(let i=0;i<array.length;i++) {
        const bar = document.createElement("div");   // For each iteration that is less than array length, which is 10, a bar will be created using docoument.createElement().
        bar.style.height = array[i]*100+"%";         //This makes each bar a certain percent of the height of the container they're in. Example: the array value is "0.52". Therefore, 0.52 x 100 = 52%. So this bar will take up just over half the container.
        bar.classList.add("bar");

        if(move && move.indices.includes(i)) {
            bar.style.backgroundColor=
            move.type=="swap"?"lime":"blue";
        }
        container.appendChild(bar);
    }
}
